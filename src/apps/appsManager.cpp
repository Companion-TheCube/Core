#include "appsManager.h"

// TODO: Go through this method by method and make sure everything makes sense. Most of this file
// was generated by copilot/chatGPT.

// TODO: The apps manager should start all the app executables that are registered in the database
// TODO: The apps manager should also stop all the app executables when the program is stopped
// TODO: The apps manager should handle updates to the app executables
// TODO: The apps manager will use the docker/dockerApi.cpp class(es) to manage the docker containers
// TODO: The apps manager should expose an API to start, stop, and update apps

// TODO: Capture stdout and stderr from native apps and log to CubeLog (Docker apps will have to use the API to log)

bool AppsManager::consoleLoggingEnabled = true;

AppsManager::AppsManager()
{
    this->appsManagerThread = std::jthread(&AppsManager::appsManagerThreadFn, this);
    this->workerThreadStopToken = this->appsManagerThread.get_stop_token();
}

AppsManager::~AppsManager()
{
    CubeLog::info("AppsManager destructor called.");
    CubeLog::debug("AppsManager destructor stopping thread.");
    std::stop_token st = this->appsManagerThread.get_stop_token();
    this->appsManagerThread.request_stop();
    this->appsManagerThread.join();
    CubeLog::debug("Stopping all apps.");
    this->stopAllApps();
    CubeLog::info("AppsManager destructor finished.");
}

void AppsManager::appsManagerThreadFn()
{
    CubeLog::info("AppsManager thread started.");
    while (CubeDB::getDBManager() == nullptr || !CubeDB::getDBManager()->isDatabaseManagerReady()) {
        CubeLog::debug("Waiting for DBManager to be initialized.");
        genericSleep(1);
    }
    auto ret = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "app_id" });
    if (ret.size() > 0) {
        for (auto row : ret) {
            this->appIDs.push_back(row[0]);
        }
    } else {
        CubeLog::error("Error getting app IDs from database.");
        return;
    }
    this->dockerApi = std::make_shared<DockerAPI>("http://127.0.0.1:2375");
    this->killAbandonedContainers();
    this->killAbandonedProcesses();


    // testing
    for(auto id: this->appIDs){
        CubeLog::warning("testing info");
        CubeLog::debug("App ID: " + id);
        CubeLog::debug("App name: " + this->getAppName(id));
        CubeLog::debug("App exec path: " + this->getAppExecPath(id));
        CubeLog::debug("App installed?: " + std::to_string(this->isAppInstalled(id)));
    }
    // end testing


    unsigned long counter = 0;
    while (true) {
        genericSleep(100);
        if (this->taskQueue.size() > 0) {
            std::function<void()> task = this->taskQueue.pop();
            task();
        }
        if (this->workerThreadStopToken.stop_requested()) {
            CubeLog::debug("AppsManager thread stop requested.");
            break;
        }

        // Restart apps that are not running
        AppsManager::consoleLoggingEnabled = false;
        if(counter % 25 == 0){
            for (auto appID : this->appIDs) {
                if(!this->isAppRunning(appID)) {
                    CubeLog::error("App is not running: " + appID + ". Restarting app.");
                    this->startApp(appID);
                    genericSleep(100);
                    if(!this->isAppRunning(appID)) {
                        CubeLog::error("App is not running: " + appID + ". Restarting app failed.");
                    }
                }
            }
        }
        

        // Check for stdout from running native apps
        for(auto appID: this->appIDs){
            if(this->isAppRunning(appID) && this->runningApps[appID]->getPID() != 0){
#ifdef _WIN32
                // first we check to see if the HANDLE is valid
                if(this->runningApps[appID]->getStdOutReadHandle() != nullptr){
                    bool bSuccess = false;
                    DWORD dwRead = 0, dwAvailable = 0;
                    CHAR chBuf[4096];
                    if(AppsManager::consoleLoggingEnabled)
                        CubeLog::debug("Checking stdout and stderr for app: " + appID);
                    if (PeekNamedPipe(this->runningApps[appID]->getStdOutReadHandle(), NULL, 0, NULL, &dwAvailable, NULL) && dwAvailable > 0) {
                        bSuccess = ReadFile(this->runningApps[appID]->getStdOutReadHandle(), chBuf, sizeof(chBuf) - 1, &dwRead, NULL);
                        if (bSuccess && dwRead > 0) {
                            chBuf[dwRead] = '\0';
                            std::string str(chBuf);
                            CubeLog::info("STDOUT - " + this->runningApps[appID]->getAppName() + ": " + str);
                        }
                    }
                }
                // then we check stderr
                if(this->runningApps[appID]->getStdErrReadHandle() != nullptr){
                    bool bSuccess = false;
                    DWORD dwRead = 0, dwAvailable = 0;
                    CHAR chBuf[4096];
                    if(AppsManager::consoleLoggingEnabled)
                        CubeLog::debug("Checking stderr for app: " + appID);
                    if(PeekNamedPipe(this->runningApps[appID]->getStdErrReadHandle(), NULL, 0, NULL, &dwAvailable, NULL) && dwAvailable > 0){
                        bSuccess = ReadFile(this->runningApps[appID]->getStdErrReadHandle(), chBuf, sizeof(chBuf) - 1, &dwRead, NULL);
                        if (bSuccess && dwRead > 0) {
                            chBuf[dwRead] = '\0';
                            std::string str(chBuf);
                            CubeLog::info("STDERR - " + this->runningApps[appID]->getAppName() + ": " + str);
                        }
                    }
                }
#endif
#ifdef __linux__
                // first we check to see if the pipe is valid
                // TODO: this entire section
#endif
                if(AppsManager::consoleLoggingEnabled)
                    CubeLog::debug("Finished checking stdout and stderr for app: " + appID);
            }
        }
        AppsManager::consoleLoggingEnabled = true;
        counter++;
    }
}

bool AppsManager::appsManagerThreadRunning()
{
    return this->appsManagerThread.joinable();
}

void AppsManager::addWorkerTask(std::function<void()> task)
{
    if (!this->appsManagerThreadRunning()) {
        CubeLog::error("AppsManager thread not running. Cannot add task.");
        return;
    }
    this->taskQueue.push(task);
}

bool AppsManager::startApp(std::string appID)
{
    CubeLog::info("Starting app: " + appID);
    std::string execPath = this->getAppExecPath(appID);
    std::string execArgs = this->getAppExecArgs(appID);
    std::string appSource = this->getAppSource(appID);
    std::string updatePath = this->getAppUpdatePath(appID);
    CubeLog::debug("App exec path: " + execPath);
    CubeLog::debug("App exec args: " + execArgs);
    CubeLog::debug("App source: " + appSource);
    CubeLog::debug("App update path: " + updatePath);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (execPath == "" || appSource == "" || updatePath == "") {
        CubeLog::error("Error starting app: " + appID + ". Missing required fields." + ". App name: " + appName);
        return false;
    }
    std::string role = this->getAppRole(appID);
    CubeLog::debug("App role: " + role);
    if (role == "") {
        CubeLog::error("Error starting app: " + appID + ". No role found." + ". App name: " + appName);
        return false;
    }
    if (role == "docker") {
        CubeLog::info("Starting docker app: " + appID);
        auto container_id = this->dockerApi->startContainer(appID);
        if (container_id) {
            CubeLog::info("Docker container started successfully. Container ID: " + container_id.value() + ". App_id: " + appID + ". App name: " + appName);
            this->runningApps[appID] = new RunningApp(0, appID, appName, execPath, execArgs, appSource, updatePath, role, "", "", "", "", std::stol(container_id.value()));
            return true;
        } else {
            CubeLog::error("Error starting docker container. App_id: " + appID + ". App name: " + appName);
            CubeLog::error("Error: " + container_id.error().message);
            return false;
        }
    } else {
        CubeLog::info("Starting native app: " + appID);
        RunningApp* temp = NativeAPI::startApp(execPath, execArgs, appID, appName, appSource, updatePath);
        if (temp) {
            CubeLog::info("Native app started successfully. App_id: " + appID + ". App name: " + appName + ". PID: " + std::to_string(temp->getPID()));
            if(this->runningApps[appID] != nullptr)
                delete(this->runningApps[appID]);
            this->runningApps[appID] = temp;
            return true;
        } else {
            CubeLog::error("Error starting native app. App_id: " + appID + ". App name: " + appName);
            return false;
        }
    }
}

bool AppsManager::stopApp(std::string appID)
{
    CubeLog::info("Stopping app: " + appID);
    std::string execPath = this->getAppExecPath(appID);
    std::string execArgs = this->getAppExecArgs(appID);
    std::string appSource = this->getAppSource(appID);
    std::string updatePath = this->getAppUpdatePath(appID);
    CubeLog::debug("App exec path: " + execPath);
    CubeLog::debug("App exec args: " + execArgs);
    CubeLog::debug("App source: " + appSource);
    CubeLog::debug("App update path: " + updatePath);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (execPath == "" || appSource == "" || updatePath == "") {
        CubeLog::error("Error stopping app: " + appID + ". Missing required fields." + ". App name: " + appName);
        return false;
    }
    std::string role = this->getAppRole(appID);
    CubeLog::debug("App role: " + role);
    if (role == "") {
        CubeLog::error("Error stopping app: " + appID + ". No role found." + ". App name: " + appName);
        return false;
    }
    if (role == "docker") {
        CubeLog::info("Stopping docker app: " + appID + ". App name: " + appName);
        auto container_id = this->dockerApi->stopContainer(appID);
        if (container_id) {
            CubeLog::info("Docker container stopped successfully: " + container_id.value() + ". App name: " + appName);
            this->runningApps.erase(appID);
            return true;
        } else {
            CubeLog::error("Error stopping docker container: " + appID + ". App name: " + appName);
            CubeLog::error("Error: " + container_id.error().message);
            return false;
        }
    } else {
        CubeLog::info("Stopping native app: " + appID + ". App name: " + appName);
        RunningApp* temp = this->runningApps[appID];
        if (temp) {
            bool pidStop = NativeAPI::stopApp(temp->getPID());
            if(!pidStop) {
                CubeLog::error("Error stopping native app by PID: " + appID + ". App name: " + appName);
                CubeLog::error("Attempting to stop native app by exec path: " + execPath + ". App name: " + appName);
                bool ret = NativeAPI::stopApp(execPath);
                if (ret) {
                    CubeLog::info("Native app stopped successfully: " + appID + ". App name: " + appName);
                    this->runningApps.erase(appID);
                    return true;
                } else {
                    CubeLog::error("Error stopping native app: " + appID + ". App name: " + appName);
                    return false;
                }
            }
            CubeLog::info("Native app stopped successfully: " + appID + ". App name: " + appName);
        } else {
            CubeLog::error("Error stopping native app: " + appID + ". App name: " + appName);
            return false;
        }
        return false;
    }
}

bool AppsManager::updateApp(std::string appID)
{
    CubeLog::info("Updating app: " + appID);
    std::string execPath = this->getAppExecPath(appID);
    std::string execArgs = this->getAppExecArgs(appID);
    std::string appSource = this->getAppSource(appID);
    std::string updatePath = this->getAppUpdatePath(appID);
    CubeLog::debug("App exec path: " + execPath);
    CubeLog::debug("App exec args: " + execArgs);
    CubeLog::debug("App source: " + appSource);
    CubeLog::debug("App update path: " + updatePath);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (execPath == "" || appSource == "" || updatePath == "") {
        CubeLog::error("Error updating app: " + appID + ". Missing required fields." + ". App name: " + appName);
        return false;
    }
    std::string role = this->getAppRole(appID);
    CubeLog::debug("App role: " + role);
    if (role == "") {
        CubeLog::error("Error updating app: " + appID + ". No role found.");
        return false;
    }
    if (role == "docker") {
        CubeLog::info("Updating docker app: " + appID + ". App name: " + appName);
        // TODO: Implement updating docker apps
        return false;
    } else {
        CubeLog::info("Updating native app: " + appID + ". App name: " + appName);
        // TODO: Implement updating native apps
        return false;
    }
}

bool AppsManager::addApp(std::string appID, std::string appName, std::string execPath, std::string execArgs, std::string appSource, std::string updatePath)
{
    CubeLog::info("Adding app: " + appID);
    std::vector<std::string> columnNames = { "app_id", "app_name", "exec_path", "exec_args", "app_source", "update_path" };
    std::vector<std::string> columnValues = { appID, appName, execPath, execArgs, appSource, updatePath };
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->insertData("apps", columnNames, columnValues);
    if (ret) {
        CubeLog::info("App added successfully: " + appID + ". App name: " + appName);
        this->startApp(appID);
        return true;
    } else {
        CubeLog::error("Error adding app: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::removeApp(std::string appID)
{
    CubeLog::info("Removing app: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error removing app: " + appID + ". App not found.");
        return false;
    }
    if (this->isAppRunning(appID)) {
        this->stopApp(appID);
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->deleteData("apps", "app_id = '" + appID + "'");
    if (ret) {
        CubeLog::info("App removed successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error removing app: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::updateAppSource(std::string appID, std::string appSource)
{
    CubeLog::info("Updating app source: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error updating app source: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "app_source" }, { appSource }, "app_id = '" + appID + "'");
    if (ret) {
        CubeLog::info("App source updated successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error updating app source: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::updateAppUpdatePath(std::string appID, std::string updatePath)
{
    CubeLog::info("Updating app update path: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error updating app update path: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "update_path" }, { updatePath }, "app_id = '" + appID + "'");
    if (ret) {
        CubeLog::info("App update path updated successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error updating app update path: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::updateAppExecPath(std::string appID, std::string execPath)
{
    CubeLog::info("Updating app exec path: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error updating app exec path: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "exec_path" }, { execPath }, "app_id = '" + appID + "'");
    if (ret) {
        CubeLog::info("App exec path updated successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error updating app exec path: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::updateAppExecArgs(std::string appID, std::string execArgs)
{
    CubeLog::info("Updating app exec args: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error updating app exec args: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "exec_args" }, { execArgs }, "app_id = '" + appID + "'");
    if (ret) {
        CubeLog::info("App exec args updated successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error updating app exec args: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::updateAppUpdateLastCheck(std::string appID, std::string updateLastCheck)
{
    CubeLog::info("Updating app update last check: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error updating app update last check: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "update_last_check" }, { updateLastCheck }, "app_id = '" + appID + "'");
    if (ret) {
        CubeLog::info("App update last check updated successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error updating app update last check: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::updateAppUpdateLastUpdate(std::string appID, std::string updateLastUpdate)
{
    CubeLog::info("Updating app update last update: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error updating app update last update: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "update_last_update" }, { updateLastUpdate }, "app_id = '" + appID + "'");
    if (ret) {
        CubeLog::info("App update last update updated successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error updating app update last update: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::updateAppUpdateLastFail(std::string appID, std::string updateLastFail)
{
    CubeLog::info("Updating app update last fail: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error updating app update last fail: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "update_last_fail" }, { updateLastFail }, "app_id = '" + appID + "'");
    if (ret) {
        CubeLog::info("App update last fail updated successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error updating app update last fail: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::updateAppUpdateLastFailReason(std::string appID, std::string updateLastFailReason)
{
    CubeLog::info("Updating app update last fail reason: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error updating app update last fail reason: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "update_last_fail_reason" }, { updateLastFailReason }, "app_id = '" + appID + "'");
    if (ret) {
        CubeLog::info("App update last fail reason updated successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error updating app update last fail reason: " + appID + ". App name: " + appName);
        return false;
    }
}

std::string AppsManager::getAppName(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app name for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "app_name" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App name: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app name for appID: " + appID);
        return "";
    }
}

std::string AppsManager::getAppExecPath(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app exec path for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "exec_path" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App exec path: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app exec path for appID: " + appID);
        return "";
    }
}

std::string AppsManager::getAppExecArgs(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app exec args for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "exec_args" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App exec args: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app exec args for appID: " + appID);
        return "";
    }
}

std::string AppsManager::getAppSource(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app source for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "app_source" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App source: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app source for appID: " + appID);
        return "";
    }
}

std::string AppsManager::getAppUpdatePath(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app update path for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "update_path" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App update path: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app update path for appID: " + appID);
        return "";
    }
}

std::string AppsManager::getAppUpdateLastCheck(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app update last check for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "update_last_check" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App update last check: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app update last check for appID: " + appID);
        return "";
    }
}

std::string AppsManager::getAppUpdateLastUpdate(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app update last update for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "update_last_update" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App update last update: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app update last update for appID: " + appID);
        return "";
    }
}

std::string AppsManager::getAppUpdateLastFail(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app update last fail for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "update_last_fail" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App update last fail: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app update last fail for appID: " + appID);
        return "";
    }
}

std::string AppsManager::getAppUpdateLastFailReason(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app update last fail reason for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "update_last_fail_reason" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App update last fail reason: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app update last fail reason for appID: " + appID);
        return "";
    }
}

std::string AppsManager::getAppRole(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("Getting app role for appID: " + appID);
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "role" }, "app_id = '" + appID + "'");
    if (data.size() > 0) {
        if(AppsManager::consoleLoggingEnabled){
            CubeLog::debug("App role: " + data[0][0]);
            CubeLog::debug("Database returned data[" + std::to_string(data.size()) + "][" + std::to_string(data[0].size()) + "]");
        }
        return data[0][0];
    } else {
        CubeLog::error("Error getting app role for appID: " + appID);
        return "";
    }
}

bool AppsManager::updateAppRole(std::string appID, std::string role)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::info("Updating app role: " + appID);
    std::string appName = this->getAppName(appID);
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error updating app role: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "role" }, { role }, "app_id = '" + appID + "'");
    if (ret) {
        if(AppsManager::consoleLoggingEnabled)
            CubeLog::info("App role updated successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error updating app role: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::addAppRole(std::string appID, std::string role)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::info("Adding app role: " + appID);
    std::string appName = this->getAppName(appID);
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error adding app role: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "role" }, { role }, "app_id = '" + appID + "'");
    if (ret) {
        if(AppsManager::consoleLoggingEnabled)
            CubeLog::info("App role added successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error adding app role: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::removeAppRole(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::info("Removing app role: " + appID);
    std::string appName = this->getAppName(appID);
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error removing app role: " + appID + ". App not found.");
        return false;
    }
    bool ret = CubeDB::getDBManager()->getDatabase("apps")->updateData("apps", { "role" }, { "" }, "app_id = '" + appID + "'");
    if (ret) {
        if(AppsManager::consoleLoggingEnabled)
            CubeLog::info("App role removed successfully: " + appID + ". App name: " + appName);
        return true;
    } else {
        CubeLog::error("Error removing app role: " + appID + ". App name: " + appName);
        return false;
    }
}

bool AppsManager::isAppRunning(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::info("Checking if app is running: " + appID);
    std::string appName = this->getAppName(appID);
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error checking if app is running: " + appID + ". App not found.");
        return false;
    }
    std::string role = this->getAppRole(appID);
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("App role: " + role);
    if (role == "") {
        CubeLog::error("Error checking if app is running: " + appID + ". No role found.");
        return false;
    }
    if (role == "docker") {
        if(AppsManager::consoleLoggingEnabled)
            CubeLog::info("Checking if docker app is running: " + appID + ". App name: " + appName);
        std::expected ret = this->dockerApi->isContainerRunning(appID);
        if (!ret) {
            CubeLog::error("Error checking if docker app is running: " + appID + ". App name: " + appName);
            CubeLog::error("Error: " + ret.error().message);
            return false;
        }
        if (ret.value()) {
            if(AppsManager::consoleLoggingEnabled)
                CubeLog::info("Docker app is running: " + appID + ". App name: " + appName);
            return true;
        } else {
            if(AppsManager::consoleLoggingEnabled)
                CubeLog::info("Docker app is not running: " + appID + ". App name: " + appName);
            return false;
        }
    } else {
        if(AppsManager::consoleLoggingEnabled)
            CubeLog::info("Checking if native app is running: " + appID + ". App name: " + appName);
        // get the PID from the map
        // check if the PID is running
        if(this->runningApps.find(appID) == this->runningApps.end()) {
            CubeLog::error("Error checking if app is running: " + appID + ". App not found.");
            return false;
        }
        long pid = this->runningApps[appID]->getPID();
        if (pid == 0) {
            CubeLog::info("Native app is not running: " + appID + ". App name: " + appName);
            return false;
        }
        if(NativeAPI::isProcessRunning(pid)) {
            if(AppsManager::consoleLoggingEnabled)
                CubeLog::info("Native app is running: " + appID + ". App name: " + appName);
            return true;
        } else {
            if(AppsManager::consoleLoggingEnabled)
                CubeLog::info("Native app is not running: " + appID + ". App name: " + appName);
            return false;
        }
        return false;
    }
}

bool AppsManager::stopAllApps()
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::info("Stopping all apps.");
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "app_id" });
    for (int i = 0; i < data.size(); i++) {
        std::string appID = data[i][0];
        this->stopApp(appID);
    }
    return true;
}

bool AppsManager::startAllApps()
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::info("Starting all apps.");
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "app_id" });
    for (int i = 0; i < data.size(); i++) {
        std::string appID = data[i][0];
        this->startApp(appID);
    }
    return true;
}

bool AppsManager::isAppInstalled(std::string appID)
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::info("Checking if app is installed: " + appID);
    std::string appName = this->getAppName(appID);
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error checking if app is installed: " + appID + ". App not found.");
        return false;
    }
    // get the role from the database
    std::string role = this->getAppRole(appID);
    if(role == "") {
        CubeLog::error("Error checking if app is installed: " + appID + ". No role found.");
        return false;
    }
    if(role == "docker"){
        if(AppsManager::consoleLoggingEnabled)
            CubeLog::info("Checking if docker app is installed: " + appID + ". App name: " + appName);
        // list all containers
        auto containers = this->dockerApi->getContainers_vec();
        if (!containers) {
            CubeLog::error("Error checking if docker app is installed: " + appID + ". App name: " + appName);
            CubeLog::error("Error: " + containers.error().message);
            return false;
        }
        auto containersVec = containers.value();
        for(auto container : containersVec) {
            // convert container json string to json object
            nlohmann::json containerJson = nlohmann::json::parse(container);
            // get the container name
            std::string containerName = containerJson["Names"][0];
            CubeLog::debug("Container name: " + containerName);
            if(containerName == appName) {
                if(AppsManager::consoleLoggingEnabled)
                    CubeLog::info("Docker app is installed: " + appID + ". App name: " + appName);
                return true;
            }
        }
        if(AppsManager::consoleLoggingEnabled)
            CubeLog::info("Docker app is not installed: " + appID + ". App name: " + appName);
        return false;
    } else if(role == "native") {
        std::string execPath = this->getAppExecPath(appID);
        if(execPath == "") {
            CubeLog::error("Error checking if app is installed: " + appID + ". No exec path found.");
            return false;
        }
        if(AppsManager::consoleLoggingEnabled)
            CubeLog::info("Checking if native app is installed: " + appID + ". App name: " + appName);
        if(NativeAPI::isExecutableInstalled(execPath)) {
            if(AppsManager::consoleLoggingEnabled)
                CubeLog::info("Native app is installed: " + appID + ". App name: " + appName);
            return true;
        } else {
            if(AppsManager::consoleLoggingEnabled)
                CubeLog::info("Native app is not installed: " + appID + ". App name: " + appName);
            return false;
        }
    }
    return true;
}

bool AppsManager::isAppUpdateAvailable(std::string appID)
{
    CubeLog::info("Checking if app update is available: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error checking if app update is available: " + appID + ". App not found.");
        return false;
    }
    // TODO: Implement checking if app update is available
    return false;
}

bool AppsManager::isAppUpdateRequired(std::string appID)
{
    CubeLog::info("Checking if app update is required: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error checking if app update is required: " + appID + ". App not found.");
        return false;
    }
    // TODO: Implement checking if app update is required
    return false;
}

bool AppsManager::isAppUpdateFailed(std::string appID)
{
    CubeLog::info("Checking if app update failed: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error checking if app update failed: " + appID + ". App not found.");
        return false;
    }
    // TODO: Implement checking if app update failed
    return false;
}

bool AppsManager::isAppUpdateCheckOverdue(std::string appID)
{
    CubeLog::info("Checking if app update check is overdue: " + appID);
    std::string appName = this->getAppName(appID);
    CubeLog::debug("App name: " + appName);
    if (appName == "") {
        CubeLog::error("Error checking if app update check is overdue: " + appID + ". App not found.");
        return false;
    }
    // TODO: Implement checking if app update check is overdue
    return false;
}

bool AppsManager::updateAllApps()
{
    CubeLog::info("Updating all apps.");
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "app_id" });
    for (int i = 0; i < data.size(); i++) {
        std::string appID = data[i][0];
        this->updateApp(appID);
    }
    return true;
}

int AppsManager::getAppCount()
{
    CubeLog::info("Getting app count.");
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "app_id" });
    CubeLog::debug("App count: " + std::to_string(data.size()));
    return data.size();
}

std::vector<std::string> AppsManager::getAppIDs()
{
    CubeLog::info("Getting app IDs.");
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "app_id" });
    std::vector<std::string> appIDs;
    for (int i = 0; i < data.size(); i++) {
        appIDs.push_back(data[i][0]);
    }
    return appIDs;
}

std::vector<std::string> AppsManager::getAppNames()
{
    CubeLog::info("Getting app names.");
    std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "app_name" });
    std::vector<std::string> appNames;
    for (int i = 0; i < data.size(); i++) {
        appNames.push_back(data[i][0]);
    }
    return appNames;
}

long AppsManager::getAppMemoryUsage(std::string appID)
{
    CubeLog::info("Getting app memory usage: " + appID);
    // TODO: Implement getting app memory usage
    return 0;
}

long AppsManager::getAppVersion(std::string appID)
{
    CubeLog::info("Getting app version: " + appID);
    // TODO: Implement getting app version
    return 0;
}

void AppsManager::checkAllAppsRunning()
{
    if(AppsManager::consoleLoggingEnabled)
        CubeLog::info("Checking if all apps are running.");
    for (auto const& app : this->runningApps) {
        if (app.second->getRole() == "docker") {
            std::expected ret = this->dockerApi->isContainerRunning(std::to_string(app.second->getContainerID()));
            if (!ret) {
                CubeLog::error("Error checking if docker container is running: " + app.second->getAppID() + ". App name: " + app.second->getAppName());
                CubeLog::error("Error: " + ret.error().message);
                continue;
            }
            if (!ret) {
                CubeLog::error("Docker container is not running: " + app.second->getAppID() + ". App name: " + app.second->getAppName());
                this->runningApps.erase(app.second->getAppID());
            }
        } else {
            // TODO: Implement checking if native apps are running
        }
    }
}

bool AppsManager::killAbandonedContainers()
{
    CubeLog::info("Killing abandoned containers.");
    std::expected containers = this->dockerApi->getContainers_vec();
    if (!containers) {
        CubeLog::error("Error getting containers.");
        return false;
    }
    for (auto const& container : containers.value()) {
        CubeLog::info("Killing abandoned container: " + container);
        // this->dockerApi->killContainer(container);
    }
    return true;
}

bool AppsManager::killAbandonedProcesses()
{
    CubeLog::info("Killing abandoned processes.");
    int killed = 0;
    for (auto appID : this->getAppIDs()) {
        // find the executable path
        std::vector<std::vector<std::string>> data = CubeDB::getDBManager()->getDatabase("apps")->selectData("apps", { "exec_path" }, "app_id = '" + appID + "'");
        if (data.size() > 0) {
            if (data[0].size() == 0) {
                CubeLog::error("Error getting exec path for app: " + appID);
                continue;
            }
            // TODO: determine if any processes are running
            bool running = false;
            if (!running) {
                CubeLog::info("No running processes found for app: " + appID);
                continue;
            }
            std::string execPath = data[0][0];
            CubeLog::debug("App exec path: " + execPath);
            // kill any running processes
            std::string command = "pkill -f " + execPath;
            CubeLog::debug("Command: " + command);
            auto ret = system(command.c_str());
            if (ret == 0) {
                CubeLog::info("Abandoned processes killed successfully.");
                killed++;
            } else {
                CubeLog::error("Error killing abandoned processes.");
            }
        }
    }
    if (killed > 0) {
        return true;
    } else {
        return false;
    }
}

void AppsManager::setConsoleLoggingEnabled(bool enabled)
{
    AppsManager::consoleLoggingEnabled = enabled;
}
