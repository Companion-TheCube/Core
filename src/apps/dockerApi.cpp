// TODO: Go through this method by method and make sure everything makes sense. Most of this file
// was generated by copilot.
// TODO: Add comments and documentation to this file.

#include "dockerApi.h"

void DockerAPI::printDockerInfo()
// TODO: remove this function. It is only used for debugging.
{
    std::expected containers = this->getContainers_json();
    if (!containers) {
        CubeLog::error(containers.error().message);
    } else {
        CubeLog::debug("Containers: " + containers.value());
    }

    std::expected containers_ved = this->getContainers_vec();
    if (!containers_ved) {
        CubeLog::error(containers_ved.error().message);
    } else {
        for (auto container_id : containers_ved.value()) {
            CubeLog::debug("Container ID: " + container_id);
        }
    }

    std::expected images = this->getImages_json();
    if (!images) {
        CubeLog::error(images.error().message);
    } else {
        CubeLog::debug("Images: " + images.value());
    }

    std::expected images_vec = this->getImages_vec();
    if (!images_vec) {
        CubeLog::error(images_vec.error().message);
    } else {
        for (auto image_id : images_vec.value()) {
            CubeLog::debug("Image ID: " + image_id);
        }
    }
}

DockerAPI::DockerAPI(const std::string& base_url)
{
    client = std::make_unique<httplib::Client>(base_url);
    if (base_url.find("/var/run/docker.sock") != std::string::npos) {
        client->set_address_family(AF_UNIX);
        client->set_default_headers({ { "Host", "localhost" } });
    }
    this->base_url = base_url;
    CubeLog::info("DockerAPI created with base_url: " + base_url);
    this->printDockerInfo();
}

DockerAPI::DockerAPI()
    : DockerAPI("http://localhost:2375")
{
}

DockerAPI::~DockerAPI()
{
    client.release();
    CubeLog::info("DockerAPI destroyed");
}

std::expected<std::string, DockerError> DockerAPI::getContainers_json()
{
    auto const& res = client->Get("/containers/json");
    if (res && res->status == 200) {
        return res->body;
    } else {
        return std::unexpected(DockerError("Error: Unable to list containers", DockerError::ErrorCodes::CONTAINER_LIST_ERROR));
    }
}

std::expected<std::vector<std::string>, DockerError> DockerAPI::getContainers_vec()
{
    std::expected<std::string, DockerError> containers = this->getContainers_json();
    if (!containers) {
        return std::unexpected(containers.error());
    }
    try {
        nlohmann::json containers_json = nlohmann::json::parse(containers.value());
        std::vector<std::string> container_ids;
        for (auto container : containers_json) {
            container_ids.push_back(container["Id"]);
        }
        return container_ids;
    } catch (nlohmann::json::parse_error& e) {
        CubeLog::error("Error parsing json: " + std::string(e.what()));
        return std::unexpected(DockerError("Error parsing json", DockerError::ErrorCodes::JSON_PARSE_ERROR));
    }
}

std::expected<std::string, DockerError> DockerAPI::getImages_json()
{
    auto res = client->Get("/images/json");
    if (res && res->status == 200) {
        return res->body;
    } else {
        return std::unexpected(DockerError("Error: Unable to list images", DockerError::ErrorCodes::IMAGE_LIST_ERROR));
    }
}

std::expected<std::vector<std::string>, DockerError> DockerAPI::getImages_vec()
{
    std::expected<std::string, DockerError> images = this->getImages_json();
    if (!images) {
        return std::unexpected(images.error());
    }
    try {
        nlohmann::json images_json = nlohmann::json::parse(images.value());
        if (!images_json.is_array()) {
            CubeLog::error("Expected images_json to be an array, but it is not.");
            return {};
        }
        std::vector<std::string> image_ids;
        for (const auto& image : images_json) {
            if (image.contains("Id") && image["Id"].is_string())
                image_ids.push_back(image["Id"]);
            else
                CubeLog::error("Expected image to contain an Id field of type string, but it does not.");
        }
        return image_ids;
    } catch (nlohmann::json::parse_error& e) {
        CubeLog::error("Error parsing json: " + std::string(e.what()));
        return std::unexpected(DockerError("Error parsing json", DockerError::ErrorCodes::JSON_PARSE_ERROR));
    }
}

std::expected<std::string, DockerError> DockerAPI::startContainer(const std::string& container_id)
{
    std::string endpoint = "/containers/" + container_id + "/start";
    auto res = client->Post(endpoint.c_str());
    if (res && res->status == 204) {
        return "Container started successfully";
    } else {
        return std::unexpected(DockerError("Error: Unable to start container", DockerError::ErrorCodes::CONTAINER_START_ERROR));
    }
}

std::expected<std::string, DockerError> DockerAPI::stopContainer(const std::string& container_id)
{
    std::string endpoint = "/containers/" + container_id + "/stop";
    auto res = client->Post(endpoint.c_str());
    if (res && res->status == 204) {
        return "Container stopped successfully";
    } else {
        return std::unexpected(DockerError("Error: Unable to stop container", DockerError::ErrorCodes::CONTAINER_STOP_ERROR));
    }
}

std::expected<std::string, DockerError> DockerAPI::inspectContainer_json(const std::string& container_id)
{
    std::string endpoint = "/containers/" + container_id + "/json";
    auto res = client->Get(endpoint.c_str());
    if (res && res->status == 200) {
        return res->body;
    } else {
        return std::unexpected(DockerError("Error: Unable to inspect container", DockerError::ErrorCodes::CONTAINER_INSPECT_ERROR));
    }
}

std::expected<bool, DockerError> DockerAPI::isContainerRunning(const std::string& container_id)
{
    std::expected container = this->inspectContainer_json(container_id);
    if (!container) {
        return std::unexpected(container.error());
    }
    try {
        nlohmann::json container_json = nlohmann::json::parse(container.value());
        return container_json["State"]["Running"];
    } catch (nlohmann::json::parse_error& e) {
        CubeLog::error("Error parsing json: " + std::string(e.what()));
        return std::unexpected(DockerError("Error parsing json", DockerError::ErrorCodes::JSON_PARSE_ERROR));
    }
}

std::expected<std::string, DockerError> DockerAPI::killContainer(const std::string& container_id)
{
    std::string endpoint = "/containers/" + container_id + "/kill";
    auto res = client->Post(endpoint.c_str());
    if (res && res->status == 204) {
        return "Container killed successfully";
    } else {
        return std::unexpected(DockerError("Error: Unable to kill container", DockerError::ErrorCodes::CONTAINER_KILL_ERROR));
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

unsigned long DockerError::errorCounter = 0;

DockerError::DockerError(const std::string& message, ErrorCodes code)
    : message(message)
    , code(code)
{
    DockerError::errorCounter++;
}

unsigned long DockerError::getErrorCounter()
{
    return DockerError::errorCounter;
}